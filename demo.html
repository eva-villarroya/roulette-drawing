<html>
	<header>
	<!-- 
	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
	-->
    	<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    	<link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    	<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />		
		
		<script src="javascripts/raphael.js"></script>
		 <style type="text/css">  
            #canvas_container {  
                width: 500px;
                height: 500px;  
                border: 0px solid #000;
                float: left;  
            }  
            #cockpit_container {  
                width: 500px;
                height: 500px;  
                border: 0px solid #000;
                float: left;  
            } 
            #inputColorScheme{
            	
            }
            #inputColorClass {  
                visibility : hidden;
            }             
        </style>
	<header>
	<body onLoad="updateDrawing();">
		<div id="cockpit_container">
			<form id="cockpit_container">
			<h3>Cockpit</h3>
			<p>Zoom: <input type="text" id="inputZoom" value="150"/></p>
			<p>Static circle radius: <input type="text" id="inputStaticCircleRadius" value="1"/></p>
			<p>Moving circle radius: <input type="text" id="inputMovingCircleRadius" value="10/13"/></p>
			<p>Distance drawing tip: <input type="text" id="inputDistanceDrawingTip" value="11/13"/></p>
			<p>Center point of shape (x,y): <input type="text" id="inputCenterCanvasX" value="250"/> <input type="text" id="inputCenterCanvasY" value="250"/></p>
			
			<p><input type="checkbox" id="inputClearCanvas" checked="checked"/> Clear canvas</p>
			
			<p> Color scheme
				<select id="inputColorScheme" onChange="showHideColors();">
  					<option value="degradation">Color degradation</option>
  					<option value="greyDegradation">Monochrome degradation</option>
  					<option value="funcolors">Fun colors</option>
  					<option value="rainbow">Rainbow</option>
  					<option value="default" selected="true">Default</option>
				</select>
				<div id="inputColorClass">
				<select id="inputColor">
  					<option value="red" selected="true">Red</option>
  					<option value="green">Green</option>
  					<option value="blue">Blue</option>
				</select>
				</div>
			</p>
			
			<input type="submit" id="applyChanges" onClick="updateDrawing(); return false;"/><input type="reset" id="resetChanges"/>
			</form>
		</div>

		<div id="canvas_container"></div>
		
		<script type="text/javascript">
		
			function updateDrawing(){
				CurveDrawer.zoom = parseFloat(document.getElementById("inputZoom").value);
				CurveDrawer.staticCircleRadius = parseFloat(document.getElementById("inputStaticCircleRadius").value);
				CurveDrawer.movingCircleRadius = parseFloat(eval(document.getElementById("inputMovingCircleRadius").value));
				CurveDrawer.distanceDrawingTip = parseFloat(eval(document.getElementById("inputDistanceDrawingTip").value));
				CurveDrawer.clearCanvas = document.getElementById("inputClearCanvas").checked;
				CurveDrawer.colorScheme = document.getElementById("inputColorScheme").options[document.getElementById("inputColorScheme").selectedIndex].value;
				CurveDrawer.colorDegradation = document.getElementById("inputColor").options[document.getElementById("inputColor").selectedIndex].value;
				CurveDrawer.centerCanvasX = parseFloat(document.getElementById("inputCenterCanvasX").value);
				CurveDrawer.centerCanvasY = parseFloat(document.getElementById("inputCenterCanvasY").value);
		
				CurveDrawer.draw();
			}
		
			function showHideColors(){
			
				var selectedColorScheme = document.getElementById("inputColorScheme").options[document.getElementById("inputColorScheme").selectedIndex].value;
				
				if(selectedColorScheme == "degradation") {
					CurveDrawer.red = 255;
					CurveDrawer.blue = 255;
					CurveDrawer.green = 255;
					document.getElementById("inputColorClass").style.visibility = "visible";
				} else {
					document.getElementById("inputColorClass").style.visibility = "hidden";
				}
			}	
		
			var CurveDrawer = 
			{
				canvasSize : 500,			
				canvasColor : '#FFF',
				clearCanvas : true,
				
				// amplification of view
				zoom : 150,

				// radius of static circle
				staticCircleRadius : 1,
				// radius of moving circle 
				movingCircleRadius : 10/13,
				// distance from radius of moving circle of drawing point
				distanceDrawingTip : 11/13,
			
				// spin step size of moving circle
				rotation : 2.5,
				// starting angle to spin from
				startAngle : 0,
				
				centerCanvasX : 200,
				centerCanvasY : 100,
			
				// shorthand
				angleTransformation :  Math.PI / 200,
			
				//colors
				red : 0,
				green : 0,
				blue : 0,
				// width of line
				strokeWidth : 1,
				
				colorScheme : 'default',
				colorDegradation : 'red',

			    paper : Raphael("canvas_container", this.canvasSize, this.canvasSize),
	
				R : function() {
					return this.staticCircleRadius * this.zoom;
				},
			
				r : function() {
					return this.movingCircleRadius * this.zoom;
				},
			
				d: function() {
					return this.distanceDrawingTip * this.zoom;
				},
				
				centerCanvas: function(){
					return this.canvasSize / 2;
				},
				
				calculatePoint :function (angle){
					var circlesDistance = this.R() - this.r();
			    	var calculatedAngle = angle * this.angleTransformation;
					var tmpCalc = (circlesDistance/this.r()) * calculatedAngle;
				
					var pointX =  circlesDistance * Math.cos(calculatedAngle) + this.d() * Math.cos(tmpCalc);
					var pointY = circlesDistance * Math.sin(calculatedAngle) - this.d() * Math.sin(tmpCalc);

					return [parseFloat(pointX.toFixed(2)), parseFloat(pointY.toFixed(2))];				
				},
			
				drawLine: function (x, y, nextX, nextY, color){
			    	var line = this.paper.path( ["M", x + this.centerCanvasX, y + this.centerCanvasY, 
			    		"L", nextX + this.centerCanvasX, nextY + this.centerCanvasY]);
			    	line.attr ("stroke", color);
			    	line.attr("stroke-width", this.strokeWidth);
				},
				
				drawPolygon: function (allPoints){	
			    	var line = this.paper.path(allPoints);
			    	line.strokeLinearGradient ("grad1", 10);
			    	line.attr("stroke-width", this.strokeWidth);
				},
			
				rainbowColors: function (angle) {
					
					this.blue = (angle * 2) % 255;
					this.green = (angle * 2) % 510;
				
					if(this.green > 254) {
						this.green = 510 - this.green;
					}
				
					this.red = (angle * 4) % 255;
				},
			
				greyscaleColors: function (angle){
					
					this.blue = angle % 510;
						
					if(this.blue > 254) {
						this.blue = 510 - this.blue;
					}
					
					this.green = angle % 510;
						
					if(this.green > 254) {
						this.green = 510 - this.green;
					}
						
					this.red = angle % 510;
						
					if(this.red > 254) {
						this.red = 510 - this.red;
					}
				},
				
				applyColorDegradation: function(colorMilestones) {
					
					var linearGradient = new Array();
					
					for(i = 0; i < colorMilestones.length; i++){
						var stepColor = new Object();
						stepColor.id = "s" + (i + 1);
						stepColor.offset = "" + i;
						stepColor.style = "stop-color:" + colorMilestones[i] + ";stop-opacity:1;";
						
						linearGradient[i] = stepColor;
					}
					
					//console.log(linearGradient);
					
					this.paper.defineLinearGradient("grad1", linearGradient);				
				},
			
				funColors: function (angle) {
					
					var module = 420;	
					var color = angle % module;
				
					if(color > (module / 2)) {
						color = (module - color);
					}
				
					return color;
				},
			
				degradateColor: function (angle){
					
					var color = this.funColors(angle);
				
					if(this.colorDegradation != "blue") {
						this.blue = color;
					}
				
					if(this.colorDegradation != "green") {	
						this.green = color;	
					}
				
					if(this.colorDegradation != "red") {			
						this.red = color;
					}
				},
				
				rgbToHex : function(r, g, b) {
    				return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
				},
				
				draw: function (){
					if(this.clearCanvas) {
						this.paper.clear(); 
					}
					
					this.paper.canvas.style.backgroundColor = this.canvasColor;
					
					var firstPoint = this.calculatePoint(0);
					var lastPoint = firstPoint;
					var angle = this.rotation;
					var keepOnDrawing = true;
					
					if(this.colorScheme == "funcolors") {
						this.blue = Math.floor((Math.random()*256)); 
						this.green = Math.floor((Math.random()*256));
					}
					
					var pointsArray = new Array();
					var colorsArray = new Array();
					
					var i = 0;
										
					do {
						this.applyColorScheme(angle);
						colorsArray[i] = [parseInt(this.red.toString(),10), parseInt(this.green.toString(),10), parseInt(this.blue.toString(),10)];
						//console.log("colorsArray " + colorsArray[i]);
						var currentPoint = this.calculatePoint(angle);
						
						pointsArray[i] = " L " +  (currentPoint[0] + this.centerCanvasX) + ":" + (currentPoint[1] + this.centerCanvasY);
						pointsArray[i+1] = " L " + (lastPoint[0] + this.centerCanvasX) + ":" + (lastPoint[1] + this.centerCanvasX);
						
						i+=2;
										
						keepOnDrawing = (currentPoint[0] != firstPoint[0]) || (currentPoint[1] != firstPoint[1]);
					
						if(keepOnDrawing) {						
							angle = angle + this.rotation;
							lastPoint = currentPoint;
						}
					} while(keepOnDrawing);	
					
					var mileStones = 10;
					var colorMil = new Array();
					
					for(i = 0; i < mileStones; i++){
						var position = Math.floor(Math.random() * colorsArray.length);
						
						while (colorsArray[position] == undefined) {
							position = Math.floor(Math.random() * colorsArray.length);
						}
						
						var rgb = colorsArray[position][2] | (colorsArray[position][1] << 8) | (colorsArray[position][0] << 16);
						colorMil[i] = '#' + rgb.toString(16);
					}
					
					this.applyColorDegradation(colorMil);
					
					var arrayToSVG = pointsArray.toString().replace(/^ L/, 'M');
					arrayToSVG = arrayToSVG.replace(/,/g, '');
					arrayToSVG = arrayToSVG.replace(/:/g, ',');
					
					this.drawPolygon(arrayToSVG);
					
				},
				
				applyColorScheme: function(angle){
					if(this.colorScheme == "degradation") {
						this.degradateColor(angle); // 2
					} else if(this.colorScheme == "greyDegradation") {
						this.greyscaleColors(angle); // 3
					}  else if(this.colorScheme == "rainbow"){
					 	this.rainbowColors(angle); // 4
					} else if(this.colorScheme == "funcolors") {
						this.red = this.funColors(angle); // makes degradation	
					} else {
						this.blue = 0; //1
						this.green = 0; //1
						this.red = 0; //1	
					}
				}				
			};
			
			// this code taken from http://stackoverflow.com/questions/4771517/raphael-js-path-line-with-gradient/11053049#11053049
			// all credits to http://stackoverflow.com/users/727551/bathz
			/*global Raphael:true*/
			(function() {
    			if (Raphael.vml) {
        			Raphael.el.strokeLinearGradient = function() {
            			// not supporting VML yet
            			return this; // maintain chainability
        			};
    			} else {
        			var setAttr = function(el, attr) {
            		var key;
            		if (attr) {
                		for (key in attr) {
                    		if (attr.hasOwnProperty(key)) {
                        		el.setAttribute(key, attr[key]);
                    		}
                		}
            		} else {
                		return document.createElementNS("http://www.w3.org/2000/svg", el);
            		}
            		return null;
        		};

        		var defLinearGrad = function(defId, stops) {
            		var def = setAttr("linearGradient");
            		var i, l;
            		def.id = defId;

            		for (i = 0, l = stops.length; i < l; i += 1) {
                		var stopEle = setAttr("stop");
                		var stop = stops[i];
                		setAttr(stopEle, stop);
                		def.appendChild(stopEle);
            		}
            		return def;
        		};

        		Raphael.el.strokeLinearGradient = function(defId, width, stops) {
            		if (stops) {
                		this.paper.defs.appendChild(defLinearGrad(defId, stops));
            		}

            		setAttr(this.node, {
                		"stroke": "url(#" + defId + ")",
                		"stroke-width": width
            		});
            		return this; // maintain chainability
        		};

        		Raphael.st.strokeLinearGradient = function(defId, width, stops) {
            		return this.forEach(function(el) {
                		el.strokeLinearGradient(defId, width, stops);
            		});
        		};

        		Raphael.fn.defineLinearGradient = function(defId, stops) {
            		this.defs.appendChild(defLinearGrad(defId, stops));
        		};
    		}
		}());
		
		</script>
	</body>
</html>
